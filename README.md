# kakaocloudschool

카카오 클라우드 스쿨 학습
/- 네트워크에 대한 학습, 아키텍처에 대한 학습

## 프론트엔드 학습

Day-1 : html과 html 태그에 관한 학습
Day-2 : 영역(div/span/iframe)과 css에 관한 학습
Day-3 : 반응형 웹(media query, flex, grid)과

## 클라이언트-서버 앱 제작 방법

1. 클라이언트 --요청--> 서버
   서버 --템플릿 엔진으로 뷰 화면 전송-->클라이언트
2. 클라이언트 --요청--> 서버
   서버 --결과--> 클라이언트가 데이터 해석해서 출력
   (서버, 클라이언트 따로 제작)
   \!이 과정에서 상호 간에 규칙이 필요\!
   1. xml
      태그 형태이나 개발자가 해석
      알아보기 쉬우나 용량 큼
   2. json
      자바스크립트 객체 표현법
      알아보기 어려우나 용량 작음

## 프로그래밍 언어 실행 방식

1. 컴파일러
   소스 코드 전체 번역 후 실행 => C, JAVA 등
2. 인터프리터
   줄 단위로 번역 후 실행 => JS, Python 등

## 데이터의 분류

1. Immutable Data
   변경 불가능한 데이터
   여러 곳에서 사용 / 옵션
2. Mutable Data
   변경 가능한 데이터
3. Scala Data
   1개의 데이터 => 이름이 데이터를 의미
4. Vector Data(List/Map)
   0개 이상의 데이터 => 이름 이외의 별도 추가되는 데이터
5. 정형 데이터
   데이터의 모양 일정 => class, RDBMS 등
6. 비정형 데이터
   데이터의 모양 일정 X => Map, NoSQL 등
7. 반정형 데이터
   비정형이지만 정형으로 만들 수 있음 => xml, json 등

## 소스 코드 버전 관리

1. 형상 관리(configuration management)
   변경 사항 관리
   소스 코드 뿐 아니라 문서 등 개발에 사용되는 모든 것 관리
2. 소스 코드 버전 관리
   git => 가장 대중적인 소스 코드 버전 관리
   github => git을 활용하여 소스 코드 버전 관리를 원격 저장소에서 가능하게 할 수 있는 서비스

=> branch : 작은 저장소
commit : 로컬에 반영
push : 서버에 반영
clone : 복제본 가져오기(git clone url)
pull : 변경된 내용 가져오기(git pull branch)

## 산술 비트 연산자의 사용

1. ~
   색상 반전 등 그래픽 작업할 때 사용
2. &
   다를 때 0을 반환하기 때문에 삭제 연산에 적용
   그래픽, 데이터 작업에 사용
3. |
   그대로의 값을 반환하기 때문에 복사, 붙여넣기, 저장 등에 적용
   조합기 구축 등 => ctrl, alt 등에 2^n 넣고 눌렸는지 유무에 대해 | 연산
4. ^
   삭제할 때 사용
   그래픽 작업 시, 이미 그린 선 위에 그대로 ^를 통해 선을 다시 그리면 전부 1이 흰색이기 때문에 지워짐

## Data 분류

Value 타입 : 변수의 데이터 자체를 보관
Reference 타입 : 변수의 데이터의 참조를 보관
--->
Scala => 변수가 데이터 자체
Vector => 변수가 대표하는 곳의 참조
--->
https://dmitripavlutin.com/value-vs-reference-javascript/

## 선언과 저장

<pre>
호출스택(큐) - 운영체제 소유
   [ ]
            스택 - 함수 소유  힙
            [ ]              [ ]
                             [ ]
            리터럴, 상수      [ ]
            함수, 콜백        [ ]
            [ ]              [ ]
            -메모리 해제나    - 인스턴스(여러 개 짜리)
               크기 변경 불가    크기 변경 가능
               (스태틱)          (동적)
</pre>

- 함수를 하나 선언할 경우
  스택에 함수가 올라가고
  호출스택은 함수의 주소를 가지고 있음
- 추가적인 작업 진행을 위해 다시 돌아가야 하는데
  이 명령어가 return
  - 호출스택(메모리)는 함수라면 참조를 기억하기 때문에
    하나만 기억하면 되기 때문에 return 하나 반환
- 추가적으로 함수를 선언하면 스택이 계속 쌓임
  마찬가지로 해당 주소를 가지고 있음

--->
js에서는 함수(정적 영역)와 데이터(동적 영역)가 따로 저장됨
그렇기 때문에 보이기에는 객체 안에 묶여있으나 this 없이 호출할 수 없음
eg) var obj = {"name":"adam", "getName:func(){}}
obj는 스택 / name과 getName은 힙 영역 / getName은 리터럴 영역을 참조
따라서 this 없이 사용하면 리터럴 영역에서만 속성을 찾기 때문에 찾을 수 없음
--->
함수와 메서드의 차이는 호출자 여부
=>결국 메서드는 보이지 않지만, 객체의 참조가 매개변수의 첫 자리

## String 활용의 중요점

<pre>
         (Front End)                                              (Back End)
            client                             connect server    application server         data server
                                                   (연결)              (일)                    (저장)

USER ==>   Browser            =request=>        (B/A)Web server
         Application         <=response=        (A)Socket server                                          
   (인스톨/다운로드의 문제)  <=traffic(비용)=>
   (플러그인을 통해 가능하게끔)                                                            |-File Server
   (etc electron)                                                                         |-Data Server -RDBMS
                                                                                               -NoSQL
                                                                                               -분산파일시스템(하둡)
</pre>

결국, 검증은 클라이언트와 서버 모두에서 이루어져야 한다.
그러나, 비용 발생의 문제가 있기 때문에 클라이언트 측에서 검증 작업이 경제적으로 이득이다.
입력이 가능한 것은 문자와 파일 밖에 없고, 파일의 내용물을 검사(전체 읽기)는 비효율적
파일 => 존재여부, 크기, 종류 등...
문자 => String, RegExp로 검증

##

List  
데이터를 연속적으로 저장

Linked List  
논리적으로 연속  
다음 주소만 기억하면 중간 끊어질 경우 연결 손실  
그 앞도 기억하는 Double Linked List  
이 상황에서 시작과 끝점을 기억하기 위해  
H(bof)와 T(eof)가 있다

Array(배열)  
입력한 순서대로 연속해서 저장  
크기가 고정

Array list(Vector)  
크기가 변할 수 있는 배열  
Capacity 와 size가 있음

Queue(FIFO)  
처음에 데이터를 추가하고  
처음에 삽입한 데이터를 제거

Deck  
양 쪽에서 삽입 삭제

## MSA

Data center의 1원화 => 단일 장애화 발생 가능성 증대  
이를 해결하기 위한 분산 => 마이크로 서비스  
이 과정을 그리드, destribution  
초창기에는 이렇게 분산된 데이터를 모으고 프로세싱 진행  
시간 소요 굉장히 증대  
현재는 마이크로 서비스에서 처리까지 진행하고  
결과를 모은다
